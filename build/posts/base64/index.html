<!DOCTYPE html>
<html lang="en">
	<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>KOTA YATAGAI | 八谷航太</title>
    <title>UTF-8対応のBase64を自作する</title><meta name="description" content="バイナリーを型付配列で扱う美しい実装" data-svelte="svelte-189on1m"><meta property="og:url" content="https://kota-yata.com" data-svelte="svelte-189on1m"><meta property="og:title" content="UTF-8対応のBase64を自作する" data-svelte="svelte-189on1m"><meta property="og:image" content="https://kota-yata.com/media/base64.webp" data-svelte="svelte-189on1m"><meta property="og:description" content="バイナリーを型付配列で扱う美しい実装" data-svelte="svelte-189on1m"><meta name="twitter:card" content="summary_large_image" data-svelte="svelte-189on1m"><meta name="twitter:site" content="@kota_yata" data-svelte="svelte-189on1m">

		

		<link rel="modulepreload" href="/_app/start-daaae108.js">
		<link rel="modulepreload" href="/_app/chunks/vendor-495f2134.js">
		<link rel="modulepreload" href="/_app/pages/__layout.svelte-be316660.js">
		<link rel="modulepreload" href="/_app/chunks/index-6747d163.js">
		<link rel="modulepreload" href="/_app/pages/posts/_path_.svelte-2d94d26d.js">
		<link rel="modulepreload" href="/_app/chunks/page-7b278a70.js">
		<link rel="modulepreload" href="/_app/chunks/className-0b25377b.js">
		<link rel="stylesheet" href="/_app/assets/start-61d1577b.css">
		<link rel="stylesheet" href="/_app/assets/pages/__layout.svelte-0136ed43.css">
		<link rel="stylesheet" href="/_app/assets/app-d7359544.css">
		<link rel="stylesheet" href="/_app/assets/pages/posts/_path_.svelte-77f41461.css">
		<link rel="stylesheet" href="/_app/assets/page-da0bc829.css">

		<script type="module">
			import { start } from "/_app/start-daaae108.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":""},
				session: {},
				host: location.host,
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/_app/pages/__layout.svelte-be316660.js"),
						import("/_app/pages/posts/_path_.svelte-2d94d26d.js")
					],
					page: {
						host: location.host, // TODO this is redundant
						path: "\u002Fposts\u002Fbase64",
						query: new URLSearchParams(""),
						params: {path:"base64"}
					}
				}
			});
		</script>
    <meta name="keyword" content="kota,yatagai,kota yatagai,八谷航太">
    <link rel="icon" href="/me.webp" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link defer
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap"
      rel="stylesheet">
    <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
      integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
    <link defer rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/a11y-dark.min.css"
      integrity="sha384-Mt8bPDNu0L2sVzon3+a8Rqtl4fmqaUmTPBEd/DTHiGFEQEFvf0fYLnU1DgK+ER2h" crossorigin="anonymous">
	</head>
	<body>
		<div id="svelte">


<header class="svelte-gbfwkw"><div class="left svelte-gbfwkw"><a href="/" class="svelte-gbfwkw">KOTA YATAGAI</a></div>
  <div class="right svelte-gbfwkw"><select name="language"><option value="JP">Japanese</option><option value="EN">English</option></select>
    <a href="/trip" sveltekit:prefetch class="svelte-gbfwkw"><img alt="to trip page" src="/airplane.svg" width="30px" height="30px"></a></div></header>

<main class="svelte-gbfwkw">
  

<div class="container svelte-izy1ym"><div class="profile svelte-izy1ym"><div class="container svelte-g32fgp"><img alt="myself" src="/me.webp" width="150px" height="150px" class="svelte-g32fgp">
  <div class="bio svelte-g32fgp"><h4 class="svelte-g32fgp">八谷航太</h4>
    <p class="svelte-g32fgp">18yo / ソフトウェア開発者</p></div>
  <ul class="svelte-g32fgp"><li class="svelte-g32fgp"><a href="/" class="svelte-g32fgp">Home</a></li><li class="svelte-g32fgp"><a href="/about" class="svelte-g32fgp">About</a></li><li class="svelte-g32fgp"><a href="/works" class="svelte-g32fgp">Works</a></li><li class="svelte-g32fgp"><a href="/contacts" class="svelte-g32fgp">Contacts</a></li></ul>
  <div class="icons svelte-g32fgp"><a href="https://github.com/kota-yata" sveltekit:prefetch class="svelte-g32fgp"><img alt="icon" src="/github.svg" width="20px" height="20px"></a><a href="https://open.spotify.com/user/jgm80x9h1j84hnk4nv3hozlaf" sveltekit:prefetch class="svelte-g32fgp"><img alt="icon" src="/spotify.svg" width="20px" height="20px"></a><a href="https://twitter.com/kota_yata" sveltekit:prefetch class="svelte-g32fgp"><img alt="icon" src="/twitter.svg" width="20px" height="20px"></a><a href="https://speakerdeck.com/kota_yata/" sveltekit:prefetch class="svelte-g32fgp"><img alt="icon" src="/speakerdeck.svg" width="20px" height="20px"></a></div>
</div></div>
  <div class="slot svelte-izy1ym"><div class="info svelte-hf3o4"><h1 class="info-title svelte-hf3o4">UTF-8対応のBase64を自作する</h1>
    <span class="info-date svelte-hf3o4">2021-08-21</span>
    <span class="info-category algorithm svelte-hf3o4">Algorithm</span></div>
  <!-- HTML_TAG_START --><p>TypeScriptでBase64を自作します。Denoの場合標準ライブラリにBase64が実装されていますので実際に利用する際はそちらを使ってください。</p>
<h2>完成品</h2>
<p>一応Denoパッケージとしても公開しています。<br>
<a href="https://github.com/kota-yata/ky_base64">https://github.com/kota-yata/ky_base64</a></p>
<h2>処理の流れ</h2>
<h4>エンコーダー</h4>
<p>Base64エンコードの大まかな流れは、</p>
<ul>
<li>文字列のバイナリーを6bitsで区切る</li>
<li>余ったビットは末尾に0を加えて6bitsにする</li>
<li>予め定められている変換表に対応する文字に変換する</li>
<li>文字数が4の整数倍に満たない場合は=で埋め合わせる</li>
</ul>
<p>という、割と単純なアルゴリズムです。最も楽に書きたいのであればバイナリーを文字列として扱うのが良いでしょう（8bits⇨6bitsが非常に楽）。しかしそれはすでに非推奨になっている、Windowオブジェクトのbtoa()がやっていたことであり、2021年に許される書き方ではありません。なので今回はバイナリーをバイナリーとして扱って実装します。</p>
<h4>デコーダー</h4>
<p>デコーダーの処理の流れは</p>
<ul>
<li>変換表に沿って文字を6bitsに変換する</li>
<li>6bitsから8bitsに区切り直す</li>
<li>UTF-8デコードで文字列にする</li>
</ul>
<p>こちらも同様にバイナリーはバイナリーとして扱います。</p>
<h1>実装</h1>
<h2>エンコーダー</h2>
<h3>文字列をUTF-8コードに変換する</h3>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextEncoder</span>();
<span class="hljs-keyword">const</span> uint8Array = encoder.<span class="hljs-title function_">encode</span>(str); <span class="hljs-comment">// strは入力の文字列</span>
</code></pre>
<p>JavaScriptの内部エンコーディングはUTF-16なので<code>str.charCodeAt(n)</code>をするとUTF-16の値が返ってくるのですが、幸い<a href="https://developer.mozilla.org/ja/docs/Web/API/TextEncoder">TextEncoder</a>を使えばUTF-8のストリームをTypedArray (Uint8Array)で受け取れます。これが無いとUTF-8エンコーダーを自作する必要があったので本当にありがたいです。</p>
<h3>シフト演算で6bitsに切り分ける</h3>
<p>Uint8Arrayからいきなり6bitsに分けることはできないので、各8bitsをシフト演算で切り分け、前の8bitsの後ろ部分と次の8bitsの前部分を足して6bitsの値を作ります。</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">splitNum</span> = (<span class="hljs-params">num: <span class="hljs-built_in">number</span>, i: <span class="hljs-built_in">number</span></span>) =&gt; {
  <span class="hljs-keyword">let</span> bitsToShift = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> mod = i % <span class="hljs-number">3</span>;
  <span class="hljs-keyword">if</span> (mod === <span class="hljs-number">0</span> || mod === <span class="hljs-number">3</span>) {
    bitsToShift = <span class="hljs-number">2</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mod === <span class="hljs-number">1</span>) {
    bitsToShift = <span class="hljs-number">4</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mod === <span class="hljs-number">2</span>) {
    bitsToShift = <span class="hljs-number">6</span>;
  }
  <span class="hljs-keyword">const</span> mainBits = (num &gt;&gt;&gt; bitsToShift);
  <span class="hljs-keyword">const</span> extraBits = (num &lt;&lt; (<span class="hljs-number">6</span> - bitsToShift)) % <span class="hljs-number">64</span>;
  <span class="hljs-keyword">return</span> { mainBits, extraBits };
};
</code></pre>
<p><code>splitNum</code>はUTF-8のエンコード値とその値の配列内インデックスを渡されます。数値を区切る位置を決めるには前の数値の後ろ部分がどれだけ残ったかがわかる必要があります。純粋にやるならその値も引数として渡してしまうという手がありますが、実は8bitsから6bitsを切り分けていくと、区切る位置に周期が見られます。<br>
<img src="https://user-images.githubusercontent.com/51294895/130304873-23105773-7c09-4c83-8ab4-f8d23ed4f068.png" alt="base64"><br>
上の画像のように、周期を3として2,4,6,2,4,6…と区切る位置が繰り返しになっている、つまり<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn></mrow><annotation encoding="application/x-tex">i\mod3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span></span></span></span></eq>を取れば区切る位置が判明するのです。区切る位置を<code>bitsToShift</code>に格納し、前部分は符号なし右シフト、後ろ部分は左シフトの後64(2の6乗)のmodをとって6bitsに収めます。</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> <span class="hljs-title function_">convert8to6</span> = (<span class="hljs-params">uint8Array: <span class="hljs-built_in">Uint8Array</span></span>) =&gt; {
  <span class="hljs-keyword">let</span> extra = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-attr">new6BitsArray</span>: <span class="hljs-built_in">number</span>[] = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; uint8Array.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> num = uint8Array[i];
    <span class="hljs-keyword">const</span> splitted = <span class="hljs-title function_">splitNum</span>(num, i);
    <span class="hljs-keyword">const</span> main = splitted.<span class="hljs-property">mainBits</span> + extra;
    new6BitsArray.<span class="hljs-title function_">push</span>(main);
    <span class="hljs-keyword">if</span> (i % <span class="hljs-number">3</span> === <span class="hljs-number">2</span> || i === uint8Array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) {
      new6BitsArray.<span class="hljs-title function_">push</span>(splitted.<span class="hljs-property">extraBits</span>);
      extra = <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      extra = splitted.<span class="hljs-property">extraBits</span>;
    }
  }
  <span class="hljs-keyword">return</span> new6BitsArray;
};
</code></pre>
<p>上のコードにおいて、<code>convert8to6</code>の入力はUTF-8のエンコード結果です。その数値一つ一つを<code>splitNum</code>に渡し、刻まれた前部分を<code>extra</code>に格納されている、前の数値の後ろ部分と加算します。<code>splitNum</code>が正しく動作すればその結果は必ず6bits(0~63)に収まるので、それを<code>new6BitsArray</code>に入れて返り値とします。上で述べたように区切る位置の周期は3で、6ビット目で区切るループの際は<code>extraBits</code>も6bitsになります。そして配列の最後も0を詰めて6bitsにする決まりなので、<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>3</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i\mod3=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></eq>もしくは最後のループの場合は<code>extraBits</code>も結果に出力します。それ以外の場合は<code>extraBits</code>を次の数値の前部分と足すために<code>extra</code>変数に一時的に代入します。</p>
<p>最後のループの処理に0を詰める処理がない理由は、<code>extraBits</code>は<code>splitNum</code>関数ですでに左ビットシフトされており、その時点で余った部分に0が詰められているからです。</p>
<h3>変換表を使って6bitsを文字列に変換する</h3>
<p>Base64で使われる表は以下の通りです。（表書くのめんどいので画像です）<br>
<img src="https://www.woolha.com/media/2020/12/base64-table.png" alt="table"></p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> base64Chars = <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>
<span class="hljs-keyword">const</span> generateEncodeResult = (<span class="hljs-attr">new6BitsArray</span>: <span class="hljs-built_in">number</span>[]): <span class="hljs-function"><span class="hljs-params">string</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> mod4 = new6BitsArray.<span class="hljs-property">length</span> % <span class="hljs-number">4</span> === <span class="hljs-number">0</span>
    ? <span class="hljs-number">0</span>
    : <span class="hljs-number">4</span> - (new6BitsArray.<span class="hljs-property">length</span> % <span class="hljs-number">4</span>);
  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;
  new6BitsArray.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">bits: <span class="hljs-built_in">number</span></span>) =&gt;</span> {
    result += base64Chars[bits];
  });
  result += <span class="hljs-string">&quot;=&quot;</span>.<span class="hljs-title function_">repeat</span>(mod4);
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<p>変換表は文字列として<code>base64Chars</code>に格納し、6bitsの数値をインデックスに検索します。最後に4の整数倍に満たない分=を加え、エンコーダーの完成です。</p>
<h2>デコーダー</h2>
<h3>変換表に沿って文字を6bitsに変換し、そのまま8bitsに区切り直す</h3>
<p>文字から数値に変換する処理と8bitsに区切り直す処理を分けてしまうと2回走査する必要があるので、まとめて一度にやってしまいます。</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> base64ToUint8Array = (<span class="hljs-attr">base64Str</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">Uint8Array</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> strArray = base64Str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/=/g</span>, <span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);
  <span class="hljs-keyword">const</span> lengthAs8Bits = (strArray.<span class="hljs-property">length</span> * <span class="hljs-number">6</span> / <span class="hljs-number">8</span>);
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(lengthAs8Bits);
  <span class="hljs-keyword">let</span> connection = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> uintIterator = <span class="hljs-number">0</span>; <span class="hljs-comment">// Because not every process in the loop below pushes to result array.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strArray.<span class="hljs-property">length</span>; i++) {
    <span class="hljs-keyword">const</span> tableIndex = base64Chars.<span class="hljs-title function_">indexOf</span>(strArray[i]);
    <span class="hljs-keyword">const</span> mod = i % <span class="hljs-number">4</span>;
    <span class="hljs-keyword">if</span> (mod === <span class="hljs-number">0</span>) {
      connection = tableIndex &lt;&lt; <span class="hljs-number">2</span>;
      <span class="hljs-keyword">continue</span>;
    }
    <span class="hljs-keyword">const</span> bitsToShift = <span class="hljs-number">6</span> - mod * <span class="hljs-number">2</span>;
    connection += tableIndex &gt;&gt;&gt; bitsToShift;
    result[uintIterator] = connection;
    uintIterator++;
    <span class="hljs-keyword">const</span> extra = tableIndex &lt;&lt; (<span class="hljs-number">8</span> - bitsToShift);
    connection = extra % <span class="hljs-number">256</span>;
  }
  <span class="hljs-keyword">return</span> result;
};
</code></pre>
<p><code>Base64ToUint8Array</code>はBase64のエンコード文字列を引数に取ります。後にUTF-8デコードで<a href="https://developer.mozilla.org/ja/docs/Web/API/TextDecoder">TextDecoderクラス</a>を使うのですが、その引数はUint8Arrayなのでこの関数でも返り値となる<code>result</code>変数はUint8Arrayです。<br>
8bitsに区切り直す過程はエンコーダーの時と似た感じで、周期を4として区切る位置が決まります。<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>4</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\mod4=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>の際は前の数値の後ろ部分が代入されている<code>connection</code>に何も入っていない、つまり数値を区切る必要はなく6bits全て<code>connection</code>に代入すれば良いので例外処理として先に済ませています。それ以外の場合は<code>6 - mod * 2</code>で区切る位置が判明します。気になる方は6bitsを続けて書いて8bitsで刻んでみると区切り位置がこの式と一致しているのがわかると思います。そして<code>connection</code>に左シフトを済ませた後ろ部分を代入して次のループに移ります。</p>
<p><code>result</code>に値を入れる際にforループのイテレータではなく<code>uintIterator</code>なる別のイテレータを使っているのは、先に述べたように<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mspace></mspace><mspace width="0.6667em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>4</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i\mod4=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6667em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></eq>の場合は例外処理が走るのでforループのイテレータと格納すべき配列のインデックスがズレるからです。さらにTypedArrayは通常の配列のようにpushで末尾に加えていくことができないため、別のイテレータを作って毎度インクリメントする必要があるのです。</p>
<h3>UTF-8デコードで文字列に戻す</h3>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> uint8Array = <span class="hljs-title function_">base64ToUint8Array</span>(encodedStr);
<span class="hljs-keyword">const</span> decoder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextDecoder</span>();
<span class="hljs-keyword">const</span> result = decoder.<span class="hljs-title function_">decode</span>(uint8Array);
<span class="hljs-keyword">return</span> result;
</code></pre>
<p>エンコード時と同様にJSの<a href="https://developer.mozilla.org/ja/docs/Web/API/TextDecoder">TextDecoderクラス</a>にお世話になります。Uint8Arrayを引数に渡せばデコード結果の文字列が返され、これがBase64のデコード結果になります。</p>
<h1>おわりに</h1>
<p>やはりこういうバイナリーを扱う処理にTSは向いてないですね。</p>
<!-- HTML_TAG_END -->
  <div class="share svelte-hf3o4"><a class="share-twitter svelte-hf3o4" target="blank"><img alt="Twitter share button" src="/twitter.svg" width="25px" height="25px"></a>
    <a class="share-pocket svelte-hf3o4" target="blank"><img alt="Pocket share button" src="/pocket.svg" width="25px" height="25px"></a>
    <a class="share-instapaper svelte-hf3o4" target="blank"><img alt="InstaPaper share button" src="/instapaper.svg" width="25px"></a></div></div>
</div></main>

<footer class="svelte-gbfwkw">@ 2021 Kota Yatagai</footer>



			<script type="application/json" data-type="svelte-data" data-url="/posts/base64.json">{"status":200,"statusText":"","headers":{"content-type":"application/json; charset=utf-8"},"body":"{\"meta\":{\"title\":\"UTF-8対応のBase64を自作する\",\"date\":\"2021-08-21\",\"category\":\"Algorithm\",\"description\":\"バイナリーを型付配列で扱う美しい実装\",\"ogp\":\"\u002Fmedia\u002Fbase64.webp\"},\"body\":\"\u003Cp\u003ETypeScriptでBase64を自作します。Denoの場合標準ライブラリにBase64が実装されていますので実際に利用する際はそちらを使ってください。\u003C\u002Fp\u003E\\n\u003Ch2\u003E完成品\u003C\u002Fh2\u003E\\n\u003Cp\u003E一応Denoパッケージとしても公開しています。\u003Cbr\u003E\\n\u003Ca href=\\\"https:\u002F\u002Fgithub.com\u002Fkota-yata\u002Fky_base64\\\"\u003Ehttps:\u002F\u002Fgithub.com\u002Fkota-yata\u002Fky_base64\u003C\u002Fa\u003E\u003C\u002Fp\u003E\\n\u003Ch2\u003E処理の流れ\u003C\u002Fh2\u003E\\n\u003Ch4\u003Eエンコーダー\u003C\u002Fh4\u003E\\n\u003Cp\u003EBase64エンコードの大まかな流れは、\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E文字列のバイナリーを6bitsで区切る\u003C\u002Fli\u003E\\n\u003Cli\u003E余ったビットは末尾に0を加えて6bitsにする\u003C\u002Fli\u003E\\n\u003Cli\u003E予め定められている変換表に対応する文字に変換する\u003C\u002Fli\u003E\\n\u003Cli\u003E文字数が4の整数倍に満たない場合は=で埋め合わせる\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003Eという、割と単純なアルゴリズムです。最も楽に書きたいのであればバイナリーを文字列として扱うのが良いでしょう（8bits⇨6bitsが非常に楽）。しかしそれはすでに非推奨になっている、Windowオブジェクトのbtoa()がやっていたことであり、2021年に許される書き方ではありません。なので今回はバイナリーをバイナリーとして扱って実装します。\u003C\u002Fp\u003E\\n\u003Ch4\u003Eデコーダー\u003C\u002Fh4\u003E\\n\u003Cp\u003Eデコーダーの処理の流れは\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E変換表に沿って文字を6bitsに変換する\u003C\u002Fli\u003E\\n\u003Cli\u003E6bitsから8bitsに区切り直す\u003C\u002Fli\u003E\\n\u003Cli\u003EUTF-8デコードで文字列にする\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003Eこちらも同様にバイナリーはバイナリーとして扱います。\u003C\u002Fp\u003E\\n\u003Ch1\u003E実装\u003C\u002Fh1\u003E\\n\u003Ch2\u003Eエンコーダー\u003C\u002Fh2\u003E\\n\u003Ch3\u003E文字列をUTF-8コードに変換する\u003C\u002Fh3\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E encoder = \u003Cspan class=\\\"hljs-keyword\\\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title class_\\\"\u003ETextEncoder\u003C\u002Fspan\u003E();\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E uint8Array = encoder.\u003Cspan class=\\\"hljs-title function_\\\"\u003Eencode\u003C\u002Fspan\u003E(str); \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F strは入力の文字列\u003C\u002Fspan\u003E\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003EJavaScriptの内部エンコーディングはUTF-16なので\u003Ccode\u003Estr.charCodeAt(n)\u003C\u002Fcode\u003EをするとUTF-16の値が返ってくるのですが、幸い\u003Ca href=\\\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fja\u002Fdocs\u002FWeb\u002FAPI\u002FTextEncoder\\\"\u003ETextEncoder\u003C\u002Fa\u003Eを使えばUTF-8のストリームをTypedArray (Uint8Array)で受け取れます。これが無いとUTF-8エンコーダーを自作する必要があったので本当にありがたいです。\u003C\u002Fp\u003E\\n\u003Ch3\u003Eシフト演算で6bitsに切り分ける\u003C\u002Fh3\u003E\\n\u003Cp\u003EUint8Arrayからいきなり6bitsに分けることはできないので、各8bitsをシフト演算で切り分け、前の8bitsの後ろ部分と次の8bitsの前部分を足して6bitsの値を作ります。\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title function_\\\"\u003EsplitNum\u003C\u002Fspan\u003E = (\u003Cspan class=\\\"hljs-params\\\"\u003Enum: \u003Cspan class=\\\"hljs-built_in\\\"\u003Enumber\u003C\u002Fspan\u003E, i: \u003Cspan class=\\\"hljs-built_in\\\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt; {\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E bitsToShift = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E mod = i % \u003Cspan class=\\\"hljs-number\\\"\u003E3\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (mod === \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E || mod === \u003Cspan class=\\\"hljs-number\\\"\u003E3\u003C\u002Fspan\u003E) {\\n    bitsToShift = \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E;\\n  } \u003Cspan class=\\\"hljs-keyword\\\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (mod === \u003Cspan class=\\\"hljs-number\\\"\u003E1\u003C\u002Fspan\u003E) {\\n    bitsToShift = \u003Cspan class=\\\"hljs-number\\\"\u003E4\u003C\u002Fspan\u003E;\\n  } \u003Cspan class=\\\"hljs-keyword\\\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (mod === \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E) {\\n    bitsToShift = \u003Cspan class=\\\"hljs-number\\\"\u003E6\u003C\u002Fspan\u003E;\\n  }\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E mainBits = (num &gt;&gt;&gt; bitsToShift);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E extraBits = (num &lt;&lt; (\u003Cspan class=\\\"hljs-number\\\"\u003E6\u003C\u002Fspan\u003E - bitsToShift)) % \u003Cspan class=\\\"hljs-number\\\"\u003E64\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E { mainBits, extraBits };\\n};\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Ccode\u003EsplitNum\u003C\u002Fcode\u003EはUTF-8のエンコード値とその値の配列内インデックスを渡されます。数値を区切る位置を決めるには前の数値の後ろ部分がどれだけ残ったかがわかる必要があります。純粋にやるならその値も引数として渡してしまうという手がありますが、実は8bitsから6bitsを切り分けていくと、区切る位置に周期が見られます。\u003Cbr\u003E\\n\u003Cimg src=\\\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F51294895\u002F130304873-23105773-7c09-4c83-8ab4-f8d23ed4f068.png\\\" alt=\\\"base64\\\"\u003E\u003Cbr\u003E\\n上の画像のように、周期を3として2,4,6,2,4,6…と区切る位置が繰り返しになっている、つまり\u003Ceq\u003E\u003Cspan class=\\\"katex\\\"\u003E\u003Cspan class=\\\"katex-mathml\\\"\u003E\u003Cmath xmlns=\\\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\\\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmspace\u003E\u003C\u002Fmspace\u003E\u003Cmspace width=\\\"0.6667em\\\"\u002F\u003E\u003Cmrow\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Em\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Eo\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Ed\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmn\u003E3\u003C\u002Fmn\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\\\"application\u002Fx-tex\\\"\u003Ei\\\\mod3\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord mathnormal\\\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace allowbreak\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.6667em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord mathrm\\\"\u003Emod\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E3\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Feq\u003Eを取れば区切る位置が判明するのです。区切る位置を\u003Ccode\u003EbitsToShift\u003C\u002Fcode\u003Eに格納し、前部分は符号なし右シフト、後ろ部分は左シフトの後64(2の6乗)のmodをとって6bitsに収めます。\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title function_\\\"\u003Econvert8to6\u003C\u002Fspan\u003E = (\u003Cspan class=\\\"hljs-params\\\"\u003Euint8Array: \u003Cspan class=\\\"hljs-built_in\\\"\u003EUint8Array\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt; {\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E extra = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-attr\\\"\u003Enew6BitsArray\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-built_in\\\"\u003Enumber\u003C\u002Fspan\u003E[] = [];\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &lt; uint8Array.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E; i++) {\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E num = uint8Array[i];\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E splitted = \u003Cspan class=\\\"hljs-title function_\\\"\u003EsplitNum\u003C\u002Fspan\u003E(num, i);\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E main = splitted.\u003Cspan class=\\\"hljs-property\\\"\u003EmainBits\u003C\u002Fspan\u003E + extra;\\n    new6BitsArray.\u003Cspan class=\\\"hljs-title function_\\\"\u003Epush\u003C\u002Fspan\u003E(main);\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (i % \u003Cspan class=\\\"hljs-number\\\"\u003E3\u003C\u002Fspan\u003E === \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E || i === uint8Array.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E - \u003Cspan class=\\\"hljs-number\\\"\u003E1\u003C\u002Fspan\u003E) {\\n      new6BitsArray.\u003Cspan class=\\\"hljs-title function_\\\"\u003Epush\u003C\u002Fspan\u003E(splitted.\u003Cspan class=\\\"hljs-property\\\"\u003EextraBits\u003C\u002Fspan\u003E);\\n      extra = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n    } \u003Cspan class=\\\"hljs-keyword\\\"\u003Eelse\u003C\u002Fspan\u003E {\\n      extra = splitted.\u003Cspan class=\\\"hljs-property\\\"\u003EextraBits\u003C\u002Fspan\u003E;\\n    }\\n  }\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E new6BitsArray;\\n};\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E上のコードにおいて、\u003Ccode\u003Econvert8to6\u003C\u002Fcode\u003Eの入力はUTF-8のエンコード結果です。その数値一つ一つを\u003Ccode\u003EsplitNum\u003C\u002Fcode\u003Eに渡し、刻まれた前部分を\u003Ccode\u003Eextra\u003C\u002Fcode\u003Eに格納されている、前の数値の後ろ部分と加算します。\u003Ccode\u003EsplitNum\u003C\u002Fcode\u003Eが正しく動作すればその結果は必ず6bits(0~63)に収まるので、それを\u003Ccode\u003Enew6BitsArray\u003C\u002Fcode\u003Eに入れて返り値とします。上で述べたように区切る位置の周期は3で、6ビット目で区切るループの際は\u003Ccode\u003EextraBits\u003C\u002Fcode\u003Eも6bitsになります。そして配列の最後も0を詰めて6bitsにする決まりなので、\u003Ceq\u003E\u003Cspan class=\\\"katex\\\"\u003E\u003Cspan class=\\\"katex-mathml\\\"\u003E\u003Cmath xmlns=\\\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\\\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmspace\u003E\u003C\u002Fmspace\u003E\u003Cmspace width=\\\"0.6667em\\\"\u002F\u003E\u003Cmrow\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Em\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Eo\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Ed\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmn\u003E3\u003C\u002Fmn\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmn\u003E2\u003C\u002Fmn\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\\\"application\u002Fx-tex\\\"\u003Ei\\\\mod3=2\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord mathnormal\\\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace allowbreak\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.6667em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord mathrm\\\"\u003Emod\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E3\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mrel\\\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E2\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Feq\u003Eもしくは最後のループの場合は\u003Ccode\u003EextraBits\u003C\u002Fcode\u003Eも結果に出力します。それ以外の場合は\u003Ccode\u003EextraBits\u003C\u002Fcode\u003Eを次の数値の前部分と足すために\u003Ccode\u003Eextra\u003C\u002Fcode\u003E変数に一時的に代入します。\u003C\u002Fp\u003E\\n\u003Cp\u003E最後のループの処理に0を詰める処理がない理由は、\u003Ccode\u003EextraBits\u003C\u002Fcode\u003Eは\u003Ccode\u003EsplitNum\u003C\u002Fcode\u003E関数ですでに左ビットシフトされており、その時点で余った部分に0が詰められているからです。\u003C\u002Fp\u003E\\n\u003Ch3\u003E変換表を使って6bitsを文字列に変換する\u003C\u002Fh3\u003E\\n\u003Cp\u003EBase64で使われる表は以下の通りです。（表書くのめんどいので画像です）\u003Cbr\u003E\\n\u003Cimg src=\\\"https:\u002F\u002Fwww.woolha.com\u002Fmedia\u002F2020\u002F12\u002Fbase64-table.png\\\" alt=\\\"table\\\"\u003E\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E base64Chars = \u003Cspan class=\\\"hljs-string\\\"\u003E&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\u002F&quot;\u003C\u002Fspan\u003E\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E generateEncodeResult = (\u003Cspan class=\\\"hljs-attr\\\"\u003Enew6BitsArray\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-built_in\\\"\u003Enumber\u003C\u002Fspan\u003E[]): \u003Cspan class=\\\"hljs-function\\\"\u003E\u003Cspan class=\\\"hljs-params\\\"\u003Estring\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E mod4 = new6BitsArray.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E % \u003Cspan class=\\\"hljs-number\\\"\u003E4\u003C\u002Fspan\u003E === \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E\\n    ? \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E\\n    : \u003Cspan class=\\\"hljs-number\\\"\u003E4\u003C\u002Fspan\u003E - (new6BitsArray.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E % \u003Cspan class=\\\"hljs-number\\\"\u003E4\u003C\u002Fspan\u003E);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E result = \u003Cspan class=\\\"hljs-string\\\"\u003E&quot;&quot;\u003C\u002Fspan\u003E;\\n  new6BitsArray.\u003Cspan class=\\\"hljs-title function_\\\"\u003Emap\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-function\\\"\u003E(\u003Cspan class=\\\"hljs-params\\\"\u003Ebits: \u003Cspan class=\\\"hljs-built_in\\\"\u003Enumber\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\\n    result += base64Chars[bits];\\n  });\\n  result += \u003Cspan class=\\\"hljs-string\\\"\u003E&quot;=&quot;\u003C\u002Fspan\u003E.\u003Cspan class=\\\"hljs-title function_\\\"\u003Erepeat\u003C\u002Fspan\u003E(mod4);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E result;\\n};\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E変換表は文字列として\u003Ccode\u003Ebase64Chars\u003C\u002Fcode\u003Eに格納し、6bitsの数値をインデックスに検索します。最後に4の整数倍に満たない分=を加え、エンコーダーの完成です。\u003C\u002Fp\u003E\\n\u003Ch2\u003Eデコーダー\u003C\u002Fh2\u003E\\n\u003Ch3\u003E変換表に沿って文字を6bitsに変換し、そのまま8bitsに区切り直す\u003C\u002Fh3\u003E\\n\u003Cp\u003E文字から数値に変換する処理と8bitsに区切り直す処理を分けてしまうと2回走査する必要があるので、まとめて一度にやってしまいます。\u003C\u002Fp\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E base64ToUint8Array = (\u003Cspan class=\\\"hljs-attr\\\"\u003Ebase64Str\u003C\u002Fspan\u003E: \u003Cspan class=\\\"hljs-built_in\\\"\u003Estring\u003C\u002Fspan\u003E): \u003Cspan class=\\\"hljs-function\\\"\u003E\u003Cspan class=\\\"hljs-params\\\"\u003EUint8Array\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E strArray = base64Str.\u003Cspan class=\\\"hljs-title function_\\\"\u003Ereplace\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-regexp\\\"\u003E\u002F=\u002Fg\u003C\u002Fspan\u003E, \u003Cspan class=\\\"hljs-string\\\"\u003E&quot;&quot;\u003C\u002Fspan\u003E).\u003Cspan class=\\\"hljs-title function_\\\"\u003Esplit\u003C\u002Fspan\u003E(\u003Cspan class=\\\"hljs-string\\\"\u003E&quot;&quot;\u003C\u002Fspan\u003E);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E lengthAs8Bits = (strArray.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E * \u003Cspan class=\\\"hljs-number\\\"\u003E6\u003C\u002Fspan\u003E \u002F \u003Cspan class=\\\"hljs-number\\\"\u003E8\u003C\u002Fspan\u003E);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E result = \u003Cspan class=\\\"hljs-keyword\\\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title class_\\\"\u003EUint8Array\u003C\u002Fspan\u003E(lengthAs8Bits);\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E connection = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E;\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E uintIterator = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; \u003Cspan class=\\\"hljs-comment\\\"\u003E\u002F\u002F Because not every process in the loop below pushes to result array.\u003C\u002Fspan\u003E\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\\\"hljs-keyword\\\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E; i &lt; strArray.\u003Cspan class=\\\"hljs-property\\\"\u003Elength\u003C\u002Fspan\u003E; i++) {\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E tableIndex = base64Chars.\u003Cspan class=\\\"hljs-title function_\\\"\u003EindexOf\u003C\u002Fspan\u003E(strArray[i]);\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E mod = i % \u003Cspan class=\\\"hljs-number\\\"\u003E4\u003C\u002Fspan\u003E;\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Eif\u003C\u002Fspan\u003E (mod === \u003Cspan class=\\\"hljs-number\\\"\u003E0\u003C\u002Fspan\u003E) {\\n      connection = tableIndex &lt;&lt; \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E;\\n      \u003Cspan class=\\\"hljs-keyword\\\"\u003Econtinue\u003C\u002Fspan\u003E;\\n    }\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E bitsToShift = \u003Cspan class=\\\"hljs-number\\\"\u003E6\u003C\u002Fspan\u003E - mod * \u003Cspan class=\\\"hljs-number\\\"\u003E2\u003C\u002Fspan\u003E;\\n    connection += tableIndex &gt;&gt;&gt; bitsToShift;\\n    result[uintIterator] = connection;\\n    uintIterator++;\\n    \u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E extra = tableIndex &lt;&lt; (\u003Cspan class=\\\"hljs-number\\\"\u003E8\u003C\u002Fspan\u003E - bitsToShift);\\n    connection = extra % \u003Cspan class=\\\"hljs-number\\\"\u003E256\u003C\u002Fspan\u003E;\\n  }\\n  \u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E result;\\n};\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003E\u003Ccode\u003EBase64ToUint8Array\u003C\u002Fcode\u003EはBase64のエンコード文字列を引数に取ります。後にUTF-8デコードで\u003Ca href=\\\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fja\u002Fdocs\u002FWeb\u002FAPI\u002FTextDecoder\\\"\u003ETextDecoderクラス\u003C\u002Fa\u003Eを使うのですが、その引数はUint8Arrayなのでこの関数でも返り値となる\u003Ccode\u003Eresult\u003C\u002Fcode\u003E変数はUint8Arrayです。\u003Cbr\u003E\\n8bitsに区切り直す過程はエンコーダーの時と似た感じで、周期を4として区切る位置が決まります。\u003Ceq\u003E\u003Cspan class=\\\"katex\\\"\u003E\u003Cspan class=\\\"katex-mathml\\\"\u003E\u003Cmath xmlns=\\\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\\\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmspace\u003E\u003C\u002Fmspace\u003E\u003Cmspace width=\\\"0.6667em\\\"\u002F\u003E\u003Cmrow\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Em\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Eo\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Ed\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmn\u003E4\u003C\u002Fmn\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmn\u003E0\u003C\u002Fmn\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\\\"application\u002Fx-tex\\\"\u003Ei\\\\mod4=0\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord mathnormal\\\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace allowbreak\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.6667em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord mathrm\\\"\u003Emod\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E4\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mrel\\\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E0\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Feq\u003Eの際は前の数値の後ろ部分が代入されている\u003Ccode\u003Econnection\u003C\u002Fcode\u003Eに何も入っていない、つまり数値を区切る必要はなく6bits全て\u003Ccode\u003Econnection\u003C\u002Fcode\u003Eに代入すれば良いので例外処理として先に済ませています。それ以外の場合は\u003Ccode\u003E6 - mod * 2\u003C\u002Fcode\u003Eで区切る位置が判明します。気になる方は6bitsを続けて書いて8bitsで刻んでみると区切り位置がこの式と一致しているのがわかると思います。そして\u003Ccode\u003Econnection\u003C\u002Fcode\u003Eに左シフトを済ませた後ろ部分を代入して次のループに移ります。\u003C\u002Fp\u003E\\n\u003Cp\u003E\u003Ccode\u003Eresult\u003C\u002Fcode\u003Eに値を入れる際にforループのイテレータではなく\u003Ccode\u003EuintIterator\u003C\u002Fcode\u003Eなる別のイテレータを使っているのは、先に述べたように\u003Ceq\u003E\u003Cspan class=\\\"katex\\\"\u003E\u003Cspan class=\\\"katex-mathml\\\"\u003E\u003Cmath xmlns=\\\"http:\u002F\u002Fwww.w3.org\u002F1998\u002FMath\u002FMathML\\\"\u003E\u003Csemantics\u003E\u003Cmrow\u003E\u003Cmi\u003Ei\u003C\u002Fmi\u003E\u003Cmspace\u003E\u003C\u002Fmspace\u003E\u003Cmspace width=\\\"0.6667em\\\"\u002F\u003E\u003Cmrow\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Em\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Eo\u003C\u002Fmi\u003E\u003Cmi mathvariant=\\\"normal\\\"\u003Ed\u003C\u002Fmi\u003E\u003C\u002Fmrow\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmtext\u003E \u003C\u002Fmtext\u003E\u003Cmn\u003E4\u003C\u002Fmn\u003E\u003Cmo\u003E=\u003C\u002Fmo\u003E\u003Cmn\u003E0\u003C\u002Fmn\u003E\u003C\u002Fmrow\u003E\u003Cannotation encoding=\\\"application\u002Fx-tex\\\"\u003Ei\\\\mod4=0\u003C\u002Fannotation\u003E\u003C\u002Fsemantics\u003E\u003C\u002Fmath\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"katex-html\\\" aria-hidden=\\\"true\\\"\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6595em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord mathnormal\\\"\u003Ei\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace allowbreak\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.6667em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6944em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord\\\"\u003E\u003Cspan class=\\\"mord mathrm\\\"\u003Emod\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.1667em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E4\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mrel\\\"\u003E=\u003C\u002Fspan\u003E\u003Cspan class=\\\"mspace\\\" style=\\\"margin-right:0.2778em;\\\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"base\\\"\u003E\u003Cspan class=\\\"strut\\\" style=\\\"height:0.6444em;\\\"\u003E\u003C\u002Fspan\u003E\u003Cspan class=\\\"mord\\\"\u003E0\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003C\u002Feq\u003Eの場合は例外処理が走るのでforループのイテレータと格納すべき配列のインデックスがズレるからです。さらにTypedArrayは通常の配列のようにpushで末尾に加えていくことができないため、別のイテレータを作って毎度インクリメントする必要があるのです。\u003C\u002Fp\u003E\\n\u003Ch3\u003EUTF-8デコードで文字列に戻す\u003C\u002Fh3\u003E\\n\u003Cpre\u003E\u003Ccode class=\\\"language-ts\\\"\u003E\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E uint8Array = \u003Cspan class=\\\"hljs-title function_\\\"\u003Ebase64ToUint8Array\u003C\u002Fspan\u003E(encodedStr);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E decoder = \u003Cspan class=\\\"hljs-keyword\\\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\\\"hljs-title class_\\\"\u003ETextDecoder\u003C\u002Fspan\u003E();\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Econst\u003C\u002Fspan\u003E result = decoder.\u003Cspan class=\\\"hljs-title function_\\\"\u003Edecode\u003C\u002Fspan\u003E(uint8Array);\\n\u003Cspan class=\\\"hljs-keyword\\\"\u003Ereturn\u003C\u002Fspan\u003E result;\\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\\n\u003Cp\u003Eエンコード時と同様にJSの\u003Ca href=\\\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fja\u002Fdocs\u002FWeb\u002FAPI\u002FTextDecoder\\\"\u003ETextDecoderクラス\u003C\u002Fa\u003Eにお世話になります。Uint8Arrayを引数に渡せばデコード結果の文字列が返され、これがBase64のデコード結果になります。\u003C\u002Fp\u003E\\n\u003Ch1\u003Eおわりに\u003C\u002Fh1\u003E\\n\u003Cp\u003Eやはりこういうバイナリーを扱う処理にTSは向いてないですね。\u003C\u002Fp\u003E\\n\"}"}</script>
		</div>
	</body>
</html>
