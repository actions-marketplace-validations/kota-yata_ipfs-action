{"meta":{"title":"久々に順列列挙アルゴリズムを書いた","date":"2021-03-30","category":"Algorithm","description":"Percomのリファクタリングと末尾呼び出し最適化の話","ogp":"/media/percom.webp"},"body":"<p>去年の夏頃に趣味で作った<a href=\"https://github.com/kota-yata/Percom\">Percom</a>なる、順列と組み合わせ列挙をやってくれるnpmパッケージを久々にリファクタリングした時の記録です。Node.js使ってて「順列/組み合わせ列挙してぇなぁ」とか思ったことないのでしばらく前にリポジトリ見てUsed by 5になってた時は不思議な気分でした。</p>\n<p><img src=\"https://user-images.githubusercontent.com/51294895/113145292-3a2a3c80-9269-11eb-9df4-9d5f74f92f57.png\" alt=\"謎のユーザーたち\"></p>\n<p>今までのアルゴリズムはほぼQiitaのコピペみたいなもんで、パッケージ作者が書いてないアルゴリズム使うのは流石によくないだろと思ったので書き換えることにしました。なぜ書けもしないパッケージを作ろうとしたのかは謎です。</p>\n<p>前の順列列挙のアルゴリズムがこちら</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">per</span> = (<span class=\"hljs-params\">array, num</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> result = [];\n  <span class=\"hljs-keyword\">if</span> (array.<span class=\"hljs-property\">length</span> &lt; num) <span class=\"hljs-keyword\">return</span> [];\n  <span class=\"hljs-keyword\">if</span> (num === <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.<span class=\"hljs-property\">length</span>; i++) {\n          result[i] = [array[i]];\n      }\n  } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.<span class=\"hljs-property\">length</span>; i++) {\n          <span class=\"hljs-keyword\">const</span> parts = array.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>);\n          parts.<span class=\"hljs-title function_\">splice</span>(i, <span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>];\n          <span class=\"hljs-keyword\">const</span> row = <span class=\"hljs-title function_\">per</span>(parts, num - <span class=\"hljs-number\">1</span>);\n          <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; row.<span class=\"hljs-property\">length</span>; j++) {\n              result.<span class=\"hljs-title function_\">push</span>([array[i]].<span class=\"hljs-title function_\">concat</span>(row[j]));\n          }\n      }\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n};\n</code></pre>\n<p>まあQiitaに書くくらいなので悪くはないと思いますが、ネスト深いしこの関数だけで完結させていて引数のエラーハンドリングとかしてないので普通に書き直しがいはありそう。</p>\n<h2>書いていく</h2>\n<p>もう一つ悲しいお知らせをすると、組み合わせ列挙の方もほぼQiitaのコピペなんですよね。しばくぞ。</p>\n<p>組み合わせの方はまた今度書き直すとして順列の方をどうにか効率的にできないかと考えていたのですが、組み合わせとかと比べるとひたすら列挙していく感じが強いのでよっぽどひどい実装しない限り速度はそこまで変わらないのでは、という気づきを経て、思いついたものをよく考えずに書くことにしました。</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">filterArray</span> = (<span class=\"hljs-params\">array, index</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> newArray = array.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, i</span>) =&gt;</span> i !== index);\n  <span class=\"hljs-keyword\">return</span> newArray;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">calcPer</span> = (<span class=\"hljs-params\">array, num, current = [], result = []</span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (current.<span class=\"hljs-property\">length</span> &gt;= num) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n  <span class=\"hljs-keyword\">let</span> tempCurrent = current.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, current.<span class=\"hljs-property\">length</span>);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; array.<span class=\"hljs-property\">length</span>; i++) {\n    tempCurrent.<span class=\"hljs-title function_\">push</span>(array[i]);\n    <span class=\"hljs-keyword\">const</span> slicedArray = <span class=\"hljs-title function_\">filterArray</span>(array, i);\n    <span class=\"hljs-keyword\">const</span> returned = <span class=\"hljs-title function_\">calcPer</span>(slicedArray, num, tempCurrent, result);\n    <span class=\"hljs-keyword\">if</span> (returned === <span class=\"hljs-literal\">null</span>) result.<span class=\"hljs-title function_\">push</span>(tempCurrent);\n    tempCurrent = current.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, current.<span class=\"hljs-property\">length</span>);\n  }\n  <span class=\"hljs-keyword\">return</span> result;\n};\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">per</span> = (<span class=\"hljs-params\">array, num</span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (array.<span class=\"hljs-property\">length</span> &lt; num) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;Number of elements of array must be greater than number to choose&#x27;</span>);\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">calcPer</span>(array, num);\n  <span class=\"hljs-keyword\">return</span> result;\n};\n</code></pre>\n<p>速度は置いといて、個人的には割と可読性の高いコードが書けたんじゃないかなと思ってます。実際に再帰的に演算をする関数と、エラーハンドリングだけ先にするメインの関数に分けて、条件分岐を減らしてネストも浅くしたので割と満足しています。詰まった点としては、配列を代入すると参照渡しになるというJavaScriptの仕様を知らずに<code>tempCurrent</code>に引数<code>current</code>を代入して訳分からん返り値をゲットしてたところくらいです。まあただハマったおかげで配列操作のどの関数が破壊的でどの関数が非破壊的なのかの区別もついたしJavaScript力も上がったので全然無駄ではなかった。</p>\n<p>一つ気になっている点として、例外処理の返り値に<code>null</code>を使うのが適切なのかどうかは疑問です。文字列で返すのも気持ち悪いので<code>null</code>にしてますが、<code>returned</code>に値が入らなかった時に<code>undefined</code>が入るだろうという僕の認識が間違っていた場合バグの温床になるので少し怖いです。</p>\n<h2>JSにおけるTail Call Optimization (おまけ)</h2>\n<p>アルゴリズム考える段階でJavaScriptにおける<a href=\"https://qiita.com/badpingpong/items/6b5035ab80850ae88a0a\">末尾呼び出し最適化(Tail Call Optimization)</a>(以下TCO)についてちょっと調べてたところ、SafariでしかTCOが実装されてないことに気づきました。なんでだろと思って色々調べていると、Stack Overflowにこんな記事が。<br>\n<a href=\"https://stackoverflow.com/questions/54719548/tail-call-optimization-implementation-in-javascript-engines\">https://stackoverflow.com/questions/54719548/tail-call-optimization-implementation-in-javascript-engines</a></p>\n<p>どうやら、TC39のミーティングで分裂が起きていて、一時はES6に実装され、ChromeもOrigin TrialsでTCOを実装していたにも関わらずEdgeチームはWindows ABI云々、Mozillaはなんだか分からんがES6策定時の議論を掘り返して反対し、最終的にはChromeもUnshippingしてしまったという経緯があったらしい。他の記事でBabelはトランスパイル時にTCOしてくれると知ってBabel使ったるわいと思っていたのですが、Babelもver.6で無効にされたらしく、現在のJavaScript環境ではTCOはされていないと認識した方が良さそうでした。Babelが無効にした経緯とかTC39で議論が起きた細かい理由とかは調べていませんが、特にTCOを実装することでスループットに逆効果とかそういう問題がないのであれば実装して欲しい感が強いですね。速度には期待していませんが現実的な範囲でスタックオーバーフローが出ることが多いのでもうちょっと耐えてくれよと思うことは多いです。</p>\n<h2>おわりに</h2>\n<p>次に暇な日ができたら組み合わせ列挙の方も書き直したいと思います。あとTypeScript移行とかもやりたい</p>\n"}